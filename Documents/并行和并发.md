# yosoro~

お　ま　た　せ

轻量化的多线程编程才是 Go 的最大亮点，不用这个不如不学

定义一个希望多线程执行的函数任务，然后 `go TriggerFunc()` 即启用了一个协程来运行该函数，实际在函数进程中**并发执行**，在 go1.8 以后默认多核**并行**运行

若主线程退出，则无论协程是否结束都会一起退出

然而，还不够。还要解决全局变量的访问安全性问题，因此要使用 channel 来完成线程之间的通信（不止能用在这里）

- channel 简介：
    - 本质是一个队列
    - 线程安全
    - 需要事先定义类型，且必须 make 初始化后才能使用；`var intChan chan int = make(chan int, 10)`
    - chan 本身是引用类型
    - 存满后继续尝试存入会**阻塞**
    - 无协程时尝试从 chan 内取值会报 dead lock
    - `close(chanVar)` 关闭管道，可以继续取值但不能存值；关闭后才能使用 for-range 遍历
    - 默认情况下管道是双向的，但可以声明成只读 `<-chan` 或只写 `chan<-`，通常用在函数参数上做限定

通常使用很多个 chan 方便控制多线程的终止