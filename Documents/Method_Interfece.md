# yosoro~

Go 没有类，但可以为结构体定义方法

方法就是一类带特殊的 **接收者** 参数的函数

**接收者** 写在 `func` 关键字和方法名之间，用 `()` 包裹，如下 `(v Vertex)` 须有结构体变量名和类型

```go
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}
```

可以为指针接收者声明方法，对其调用会修改接收者指向的值；而默认的值接收者会对原始值的 **副本** 进行操作，对于大型结构体会降低操作效率（调用时复制）



可以给非结构体类型声明方法

```go
type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f < 0 {
        return float64(-f)
    }
    return float64(f)
}
```

**注意** ：接收者的类型定义和方法声明必须在同一包内；不能为内建类型（如 `int` ）声明方法

## 方法与指针重定向

如果函数声明中接收指针参数或值，则调用时必须对应地传入一个指针 `&var` 或值 `var` 

但对于接收者为指针或值的方法则可以由值和指针调用，编译器自行解释

## 接口

**接口类型** 是由一组方法签名定义的集合

接口类型的变量可以保存任何实现了这些方法的值

```go
type I interface {
    M()
}
```



接口可以作为值传递到函数参数或返回值

在内部，接口值可以看做包含值和具体类型的元组：`(value, type)` 其调用方法时会执行该底层类型的同名方法

接口值能接受 `nil` 作为底层值，对其的处理一般在方法中补充；但不能由 `nil` 的接口值调用方法

### 空接口

指定了零个方法的接口值被称为空接口

`interface {}` 

空接口可保存任何类型的值（因为每个类型都至少实现了零个方法）被用来处理位置类型的值

### 类型断言

**类型断言** 提供了访问接口底层具体值的方式

`t := i.(T)` 该语句断言接口值 i 保存了具体类型 T ，并将其底层类型为 T 的值赋予变量 t

若 i 并未保存 T 类型的值（T 不正确），该语句会触发一个 panic

```go
t, ok := i.(T)
```

上述语句类似读取映射，若 i 未保存 T 类型则 ok 值为 false 而 t 值为 T 类型的零值

### 类型选择

```go
switch v := i.(type) {
    case T:
    	// v 的类型为 T
    case S:
    	// v 的类型为 S
    default:
    	// 没有匹配，v 与 i 的类型相同
}
```

